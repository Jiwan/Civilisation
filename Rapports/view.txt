Espace de noms Drawable : 
TileFlyWeight est un pattern poids-mouche (flyweight) pour les tiles (textures) que nous allons utiliser pour la vue de notre jeu.
En effet, de nombreuses cases de la carte de notre jeu ainsi que les différentes unités utilisent les mêmes textures. Afin d'éviter d'encombrer
inutillement la mémoire en chargeant plusieurs fois la même texture, nous allons partager une même instance de cette texture aux différents objets la nécéssitant.
Pour cela, notre pattern flyweight contient une hashmap liant un nom de texture à son contenu. 
Par exemple si plusieurs objets demande le tile "water.png", ceux-ci partageront une unique instance du tile "water.png". 
A noter que si aucun objet ne demande "water.png", la texture ne sera jamais chargé en mémoire.
On pourrait se demander si il n'est pas plus judicieux de partager les objets cases de notre carte et pas uniquement leurs textures. 
En effet nous pourriont décider que toutes les cases "moutain" soit partagées car elles contiennent les mêmes caractéristiques 
(hormis leur position, une caractéristique qui serait alors passé en état externe lors des manipulations).
Nous projetons de créer des cases avec des caractéristiques variant au cours du temps (par exemple, la nourriture diminue en cas de guerre de proche), 
il est alors difficile envisageable de contenir toutes les caractéristiques en état externe. C'est dans cette optique que nous ne partageons uniquement les textures des cases.
Notre poids-mouche est un singleton car il n'y aucune raison de l'instancier plusieurs fois au cours d'une même partie.

La classe Tile a son constructeur privé car nous voulons que les Tiles soit chargés uniquement à partir du FlyWeight. 
On remarquera également que la méthode \textit{Draw} prend un paramètre d'état externe qui est la position du tile que nous voulons dessiner 
(comme vu précédement le pattern FlyWeight oblige à passer les états non-partagés d'un objet à l'aide de paramètres externes).

Nous avons mit à la disposition des dévellopeurs une interface ISprite pour dessiner des animations. Un sprite consistant en une série de textures que l'on fait défiler afin de donner l'illusion 
d'une animation. L'implémentation de cette interface est faite avec la classe Sprite qui gère des animations basiques. L'intérêt d'une interface ISprite est de pouvoir facilement changer l'implémentation
sans réecrire tout le code client.

Pour la vue, nous avons également l'interface IDrawable qui doit être implémenté par toutes les entités que nous voudrons dessiner (les cases, les unités, ...). 
Cette interface contient deux fonctions :
- Draw qui permet de dessiner l'entité, le paramètre IGraphiqueEngine sera détaillé par la suite.
- Update qui met à jour l'état graphique de l'entité que nous allons dessiner. En effet, si nous utilisons des animations, il est important de modifier l'état de la prochaine frame que nous allons dessiner.
Le paramètre deltaTime est la différence de temps entre la frame précédente et la frame courante. Nous exprimeront l'ensemble de nos animations à l'aide de ce paramètre, ainsi peu importe la puissance de la machine
sur laquelle tourne le jeu, les animations seront toujours de même durée et donc fluides.

Nous esperont implémenter par la suite un pattern bridge pour séparer l'interface de notre moteur graphique de son implémentation. 
En effet, il serait élégant de pouvoir faire tourner notre jeu en dehors de l'environment WPF (XNA, DirectX, OpenGL par exemple).
Pour cela nous avons imaginé une interface IGraphicEngine qui contiendra les appels graphiques nécéssaires au fonctionnement de notre jeux (DrawSprite, CreateSprite, LoadTile, ...).
L'implémentation dans le cas de WPF est la classe WPFGraphicEngine, pour XNA se cera XNAGraphicEngine, ...
Dans toutes les librairies graphiques nous retrouvons des appels à des primitives graphiques identiques(DrawTexture, LoadPNGTexture, ...). 
L'interface IGraphicEngine dépend donc de son implémentation bas-niveau qui est l'interface IGraphicPrimitive qui contient l'ensemble de ces appels primitifs.
Pour WPF nous créont alors une classe WPFGraphicPrimitive pour implémenter cette interface IGraphicPrimitive. Il en va des même pour les autres environments que nous désiront utiliser.
Ce pattern bridge ne contient pour l'instant aucune méthode car nous ne sommes pas encore certains des fonctions graphiques nécéssaires à notre jeu.


 

